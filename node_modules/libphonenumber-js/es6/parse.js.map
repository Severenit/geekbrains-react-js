{"version":3,"sources":["../source/parse.js"],"names":["parse_phone_number_digits","parse_national_number_and_country_calling_code","VALID_PUNCTUATION","PLUS_CHARS","matches_entirely","Metadata","get_number_type","check_number_length_for_type","parseRFC3966","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","VALID_DIGITS","CAPTURING_EXTN_DIGITS","RFC3966_EXTN_PREFIX","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","default_options","country","parse","arg_1","arg_2","arg_3","arg_4","sort_out_arguments","text","options","metadata","defaultCountry","hasCountry","Error","parse_input","formatted_phone_number","number","ext","parse_phone_number","national_number","countryCallingCode","selectedCountry","extended","length","valid","nationalNumberPattern","result","possible","possibleLengths","is_possible_number","undefined","phone","is_viable_phone_number","extract_formatted_phone_number","starts_at","search","slice","replace","strip_national_prefix","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","any_groups_were_captured","nationalPrefixTransformRule","find_country_code","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","original_country","_find_country_code","leadingDigits","TypeError","countries","strip_extension","start","number_without_extension","matches","match","i","is_international","get_country_and_national_number_international","chooseCountryByCountryCallingCode","get_country_and_national_number_local","default_country","potential_national_number","indexOf","with_extension_stripped"],"mappings":";;AAAA;AACA;AACA;AACA;;AAEA,SAECA,yBAFD,EAGCC,8CAHD,EAICC,iBAJD,EAKCC,UALD,EAMCC,gBAND,QAQK,UARL;;AAUA,OAAOC,QAAP,MAAqB,YAArB;;AAEA,OAAOC,eAAP,IAA0BC,4BAA1B,QAA8D,SAA9D;;AAEA,SAASC,YAAT,QAA6B,WAA7B;;AAEA;AACA,IAAMC,qBAAqB,CAA3B;;AAEA;AACA;AACA,IAAMC,qBAAqB,EAA3B;;AAEA;AACA;AACA,IAAMC,0BAA0B,GAAhC;;AAEA;AACA;AACA,OAAO,IAAMC,eAAe,4CAArB;;AAEP;AACA;AACA,IAAMC,wBAAwB,OAAOD,YAAP,GAAsB,SAApD;;AAEA;AACA,IAAME,sBAAsB,OAA5B;;AAEA;;;;;;;;;;;;;;;AAeA,IAAMC,4BACLD,sBACAD,qBADA,GACwB,GADxB,GAEA,cAFA,GAGA,iEAHA,GAIA,yDAJA,GAKA,4BALA,GAMAA,qBANA,GAMwB,KANxB,GAOA,SAPA,GAOYD,YAPZ,GAO2B,UAR5B;;AAUA;AACA;AACA,IAAMI,eAAe,IAAIC,MAAJ,CAAW,QAAQF,yBAAR,GAAoC,IAA/C,EAAqD,GAArD,CAArB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMG,kCAAkC,MAAMN,YAAN,GAAqB,IAArB,GAA4BH,kBAA5B,GAAiD,GAAzF;AACA;AACA;AACA;AACA;AACA,IAAMU,qBACJ,MAAMhB,UAAN,GAAmB,QAAnB,GACA,KADA,GAEC,GAFD,GAEOD,iBAFP,GAE2B,IAF3B,GAGC,GAHD,GAGOU,YAHP,GAGsB,GAHtB,GAIA,OAJA,GAKA,GALA,GAMCV,iBAND,GAOCU,YAPD,GAQA,IATF;;AAWA;AACA;AACA,IAAMQ,6BAA6B,IAAIH,MAAJ;AAElC;AACA,MACCC,+BADD,GAEA,GAFA,GAGA,GAHA;AAIA;AACA,GALA,GAMCC,kBAND;AAOC;AACA,KARD,GAQSJ,yBART,GAQqC,IARrC,GASA,GAZkC,EAcnC,GAdmC,CAAnC;;AAgBA;AACA,IAAMM,6BAA6B,IAAIJ,MAAJ,CAAW,MAAMd,UAAN,GAAmBS,YAAnB,GAAkC,GAA7C,CAAnC;;AAEA;AACA,IAAMU,iCAAiC,IAAIL,MAAJ,CAAW,OAAOL,YAAP,GAAsB,KAAjC,CAAvC;;AAEA,IAAMW,kBACN;AACCC,UAAS;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA,CADA,CA+BA,eAAe,SAASC,KAAT,CAAeC,KAAf,EAAsBC,KAAtB,EAA6BC,KAA7B,EAAoCC,KAApC,EACf;AAAA,2BACqCC,mBAAmBJ,KAAnB,EAA0BC,KAA1B,EAAiCC,KAAjC,EAAwCC,KAAxC,CADrC;AAAA,KACSE,IADT,uBACSA,IADT;AAAA,KACeC,OADf,uBACeA,OADf;AAAA,KACwBC,QADxB,uBACwBA,QADxB;;AAGC;;;AACA,KAAID,QAAQE,cAAR,IAA0B,CAACD,SAASE,UAAT,CAAoBH,QAAQE,cAA5B,CAA/B,EACA;AACC,QAAM,IAAIE,KAAJ,uBAA8BJ,QAAQE,cAAtC,CAAN;AACA;;AAED;;AATD,oBAUiDG,YAAYN,IAAZ,CAVjD;AAAA,KAUiBO,sBAVjB,gBAUSC,MAVT;AAAA,KAUyCC,GAVzC,gBAUyCA,GAVzC;;AAYC;;;AACA,KAAI,CAACF,sBAAL,EACA;AACC,SAAO,EAAP;AACA;;AAhBF,2BAwBGG,mBAEDH,sBAFC,EAGDN,QAAQE,cAHP,EAIDD,QAJC,CAxBH;AAAA,KAoBET,OApBF,uBAoBEA,OApBF;AAAA,KAqBEkB,eArBF,uBAqBEA,eArBF;AAAA,KAsBEC,kBAtBF,uBAsBEA,kBAtBF;;AA+BC,KAAI,CAACV,SAASW,eAAT,EAAL,EACA;AACC,SAAOZ,QAAQa,QAAR,GAAmB,EAAEF,sCAAF,EAAnB,GAA4C,EAAnD;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAID,gBAAgBI,MAAhB,GAAyBrC,kBAAzB,IACHiC,gBAAgBI,MAAhB,GAAyBpC,kBAD1B,EAEA;AACC;AACA,SAAO,EAAP;AACA;;AAED;AACA;AACA;AACA,KAAMqC,QAAQvB,WAAWpB,iBAAiBsC,eAAjB,EAAkC,IAAIzB,MAAJ,CAAWgB,SAASe,qBAAT,EAAX,CAAlC,CAAX,GAA6F,IAA7F,GAAoG,KAAlH;;AAEA,KAAI,CAAChB,QAAQa,QAAb,EACA;AACC,SAAOE,QAAQE,OAAOzB,OAAP,EAAgBkB,eAAhB,EAAiCF,GAAjC,CAAR,GAAgD,EAAvD;AACA;;AAED,QAAO;AACNhB,kBADM;AAENmB,wCAFM;AAGNI,cAHM;AAING,YAAWH,QAAQ,IAAR,GAAgBf,QAAQa,QAAR,KAAqB,IAAtB,IAA+BZ,SAASkB,eAAT,EAA/B,IAA6DC,mBAAmBV,eAAnB,EAAoCC,uBAAuBU,SAA3D,EAAsEpB,QAAtE,CAJjF;AAKNqB,SAAWZ,eALL;AAMNF;AANM,EAAP;AAQA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,sBAAT,CAAgChB,MAAhC,EACP;AACC,QAAOA,OAAOO,MAAP,IAAiBrC,kBAAjB,IACNL,iBAAiBmC,MAAjB,EAAyBnB,0BAAzB,CADD;AAEA;;AAED,OAAO,SAASoC,8BAAT,CAAwCzB,IAAxC,EACP;AACC,KAAI,CAACA,IAAD,IAASA,KAAKe,MAAL,GAAcnC,uBAA3B,EACA;AACC,SAAO,EAAP;AACA;;AAED;;AAEA,KAAM8C,YAAY1B,KAAK2B,MAAL,CAAYrC,0BAAZ,CAAlB;;AAEA,KAAIoC,YAAY,CAAhB,EACA;AACC,SAAO,EAAP;AACA;;AAED,QAAO1B;AACN;AADM,EAEL4B,KAFK,CAECF,SAFD;AAGN;AAHM,EAILG,OAJK,CAIGtC,8BAJH,EAImC,EAJnC,CAAP;AAKA;;AAED;AACA,OAAO,SAASuC,qBAAT,CAA+BtB,MAA/B,EAAuCN,QAAvC,EACP;AACC,KAAI,CAACM,MAAD,IAAW,CAACN,SAAS6B,wBAAT,EAAhB,EACA;AACC,SAAOvB,MAAP;AACA;;AAED;AACA,KAAMwB,0BAA0B,IAAI9C,MAAJ,CAAW,SAASgB,SAAS6B,wBAAT,EAAT,GAA+C,GAA1D,CAAhC;AACA,KAAME,0BAA0BD,wBAAwBE,IAAxB,CAA6B1B,MAA7B,CAAhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,CAACyB,uBAAL,EACA;AACC,SAAOzB,MAAP;AACA;;AAED,KAAI2B,oCAAJ;;AAEA;AACA;AACA,KAAMC,2BAA2BH,wBAAwBA,wBAAwBlB,MAAxB,GAAiC,CAAzD,CAAjC;;AAEA;AACA,KAAIb,SAASmC,2BAAT,MAA0CD,wBAA9C,EACA;AACCD,gCAA8B3B,OAAOqB,OAAP,CAAeG,uBAAf,EAAwC9B,SAASmC,2BAAT,EAAxC,CAA9B;AACA;AACD;AACA;AALA,MAOA;AACCF,iCAA8B3B,OAAOoB,KAAP,CAAaK,wBAAwB,CAAxB,EAA2BlB,MAAxC,CAA9B;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE,QAAOoB,2BAAP;AACF;;AAED,OAAO,SAASG,iBAAT,CAA2BC,oBAA3B,EAAiDC,qBAAjD,EAAwEtC,QAAxE,EACP;AACC;AACA,KAAMuC,qBAAqBvC,SAASwC,mBAAT,GAA+BH,oBAA/B,CAA3B;;AAEA;AACA;AACA,KAAIE,mBAAmB1B,MAAnB,KAA8B,CAAlC,EACA;AACC,SAAO0B,mBAAmB,CAAnB,CAAP;AACA;;AAED,KAAME,mBAAmBzC,SAASW,eAAT,EAAzB;AACA,KAAMpB,UAAUmD,mBAAmBH,kBAAnB,EAAuCD,qBAAvC,EAA8DtC,QAA9D,CAAhB;AACAA,UAAST,OAAT,CAAiBkD,gBAAjB;AACA,QAAOlD,OAAP;AACA;;AAED;AACA,SAASmD,kBAAT,CAA4BH,kBAA5B,EAAgDD,qBAAhD,EAAuEtC,QAAvE,EACA;AAAA;AAAA;AAAA;;AAAA;AACC,oCAAsBuC,kBAAtB,4GACA;AAAA,OADWhD,OACX;;AACCS,YAAST,OAAT,CAAiBA,OAAjB;;AAEA;AACA,OAAIS,SAAS2C,aAAT,EAAJ,EACA;AACC,QAAIL,yBACHA,sBAAsBb,MAAtB,CAA6BzB,SAAS2C,aAAT,EAA7B,MAA2D,CAD5D,EAEA;AACC,YAAOpD,OAAP;AACA;AACD;AACD;AACA;AATA,QAUK,IAAIlB,gBAAgB,EAAEgD,OAAOiB,qBAAT,EAAgC/C,gBAAhC,EAAhB,EAA2DS,SAASA,QAApE,CAAJ,EACL;AACC,YAAOT,OAAP;AACA;AACD;AApBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBC;;AAED;AACA,SAASM,kBAAT,CAA4BJ,KAA5B,EAAmCC,KAAnC,EAA0CC,KAA1C,EAAiDC,KAAjD,EACA;AACC,KAAIE,aAAJ;AACA,KAAIC,gBAAJ;AACA,KAAIC,iBAAJ;;AAEA;AACA;AACA,KAAI,OAAOP,KAAP,KAAiB,QAArB,EACA;AACCK,SAAOL,KAAP;AACA,EAHD,MAIK,MAAM,IAAImD,SAAJ,CAAc,8CAAd,CAAN;;AAEL;AACA;AACA;AACA,KAAI,OAAOlD,KAAP,KAAiB,QAArB,EACA;AACC,MAAIE,KAAJ,EACA;AACCG,wBAAYE,gBAAgBP,KAA5B,IAAsCC,KAAtC;AACAK,cAAWJ,KAAX;AACA,GAJD,MAMA;AACCG,aAAU,EAAEE,gBAAgBP,KAAlB,EAAV;AACAM,cAAWL,KAAX;AACA;AACD;AACD;AACA;AACA;AAfA,MAiBA;AACC,OAAIA,KAAJ,EACA;AACCI,cAAWL,KAAX;AACAM,eAAWL,KAAX;AACA,IAJD,MAMA;AACCK,eAAWN,KAAX;AACA;AACD;;AAED;AACA,KAAI,CAACM,QAAD,IAAa,CAACA,SAAS6C,SAA3B,EACA;AACC,QAAM,IAAI1C,KAAJ,CAAU,sBAAV,CAAN;AACA;;AAED;AACA,KAAIJ,OAAJ,EACA;AACCA,yBAAeT,eAAf,EAAmCS,OAAnC;AACA,EAHD,MAKA;AACCA,YAAUT,eAAV;AACA;;AAED,QAAO,EAAEQ,UAAF,EAAQC,gBAAR,EAAiBC,UAAU,IAAI5B,QAAJ,CAAa4B,QAAb,CAA3B,EAAP;AACA;;AAED;AACA;AACA;AACA,SAAS8C,eAAT,CAAyBxC,MAAzB,EACA;AACC,KAAMyC,QAAQzC,OAAOmB,MAAP,CAAc1C,YAAd,CAAd;AACA,KAAIgE,QAAQ,CAAZ,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAMC,2BAA2B1C,OAAOoB,KAAP,CAAa,CAAb,EAAgBqB,KAAhB,CAAjC;AACA;AACA,KAAI,CAACzB,uBAAuB0B,wBAAvB,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED,KAAMC,UAAU3C,OAAO4C,KAAP,CAAanE,YAAb,CAAhB;AACA,KAAIoE,IAAI,CAAR;AACA,QAAOA,IAAIF,QAAQpC,MAAnB,EACA;AACC,MAAIoC,QAAQE,CAAR,KAAc,IAAd,IAAsBF,QAAQE,CAAR,EAAWtC,MAAX,GAAoB,CAA9C,EACA;AACC,UAAO;AACNP,YAAS0C,wBADH;AAENzC,SAAS0C,QAAQE,CAAR;AAFH,IAAP;AAIA;AACDA;AACA;AACD;;AAED,SAAShC,kBAAT,CAA4BV,eAA5B,EAA6C2C,gBAA7C,EAA+DpD,QAA/D,EACA;AACC,SAAQ1B,6BAA6BmC,eAA7B,EAA8CW,SAA9C,EAAyDpB,QAAzD,CAAR;AAEC,OAAK,aAAL;AACC,UAAO,IAAP;AACD;AACA;AACA;AACC,UAAO,KAAP;AAPF;AASA;;AAED;;;;AAIA,SAASqD,6CAAT,CAAuDhB,oBAAvD,EAA6E5B,eAA7E,EAA8FT,QAA9F,EACA;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAMT,UAAU6C,kBAAkBC,oBAAlB,EAAwC5B,eAAxC,EAAyDT,QAAzD,CAAhB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAT,WAAUS,SAAST,OAAT,CAAiBA,OAAjB,CAAV,GAAsCS,SAASsD,iCAAT,CAA2CjB,oBAA3C,CAAtC;;AAEA,QAAO,EAAE5B,gCAAF,EAAmBlB,gBAAnB,EAAP;AACA;;AAED;;;;AAIA,SAASgE,qCAAT,CAA+ClD,sBAA/C,EAAuEmD,eAAvE,EAAwFxD,QAAxF,EACA;AACC,KAAMT,UAAUiE,eAAhB;AACAxD,UAAST,OAAT,CAAiBA,OAAjB;;AAEA,KAAIkB,kBAAkB1C,0BAA0BsC,sBAA1B,CAAtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAMoD,4BAA4B7B,sBAAsBnB,eAAtB,EAAuCT,QAAvC,CAAlC;;AAEA;AACA,KAAIA,SAASkB,eAAT,EAAJ,EACA;AACC;AACA;AACA;AACA;AACA,UAAQ5C,6BAA6BmF,yBAA7B,EAAwDrC,SAAxD,EAAmEpB,QAAnE,CAAR;AAEC,QAAK,WAAL;AACA;AACA,QAAK,gBAAL;AACC;AACD;AACCS,sBAAkBgD,yBAAlB;AAPF;AASA,EAfD,MAiBA;AACC;AACA;AACA;AACA;AACA;AACA;AACA,MAAItF,iBAAiBsC,eAAjB,EAAkCT,SAASe,qBAAT,EAAlC,KACF,CAAC5C,iBAAiBsF,yBAAjB,EAA4CzD,SAASe,qBAAT,EAA5C,CADH,EAEA;AACC;AACA,GAJD,MAMA;AACCN,qBAAkBgD,yBAAlB;AACA;AACD;;AAED,QAAO,EAAEhD,gCAAF,EAAmBlB,gBAAnB,EAAP;AACA;;AAED;;;;AAIA,SAASa,WAAT,CAAqBN,IAArB,EACA;AACC;AACA,KAAIA,QAAQA,KAAK4D,OAAL,CAAa,MAAb,MAAyB,CAArC,EACA;AACC,SAAOnF,aAAauB,IAAb,CAAP;AACA;;AAED,KAAIQ,SAASiB,+BAA+BzB,IAA/B,CAAb;;AAEA;AACA,KAAI,CAACwB,uBAAuBhB,MAAvB,CAAL,EACA;AACC,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAMqD,0BAA0Bb,gBAAgBxC,MAAhB,CAAhC;AACA,KAAIqD,wBAAwBpD,GAA5B,EACA;AACC,SAAOoD,uBAAP;AACA;;AAED,QAAO,EAAErD,cAAF,EAAP;AACA;;AAED,SAASU,MAAT,CAAgBzB,OAAhB,EAAyBkB,eAAzB,EAA0CF,GAA1C,EACA;AACC,KAAMS,SACN;AACCzB,kBADD;AAEC8B,SAAQZ;AAFT,EADA;;AAMA,KAAIF,GAAJ,EACA;AACCS,SAAOT,GAAP,GAAaA,GAAb;AACA;;AAED,QAAOS,MAAP;AACA;;AAED;;;;AAIA,SAASR,kBAAT,CAA4BH,sBAA5B,EAAoDmD,eAApD,EAAqExD,QAArE,EACA;AAAA,6BACwChC,+CAA+CqC,sBAA/C,EAAuEL,QAAvE,CADxC;AAAA,KACSU,kBADT,yBACSA,kBADT;AAAA,KAC6BJ,MAD7B,yBAC6BA,MAD7B;;AAGC,KAAI,CAACA,MAAL,EACA;AACC,SAAO,EAAEI,sCAAF,EAAP;AACA;;AAED,KAAIA,kBAAJ,EACA;AACC,MAAMM,UAASqC,8CAA8C3C,kBAA9C,EAAkEJ,MAAlE,EAA0EN,QAA1E,CAAf;AACAgB,UAAON,kBAAP,GAA4BA,kBAA5B;AACA,SAAOM,OAAP;AACA;;AAED,KAAIwC,eAAJ,EACA;AACC,MAAMxC,WAASuC,sCAAsClD,sBAAtC,EAA8DmD,eAA9D,EAA+ExD,QAA/E,CAAf;AACAA,WAAST,OAAT,CAAiBiE,eAAjB;AACAxC,WAAON,kBAAP,GAA4BV,SAASU,kBAAT,EAA5B;AACA,SAAOM,QAAP;AACA;;AAED,QAAO,EAAP;AACA","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of 17th November, 2016.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport\r\n{\r\n\tparse_phone_number_digits,\r\n\tparse_national_number_and_country_calling_code,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tmatches_entirely\r\n}\r\nfrom './common'\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport get_number_type, { check_number_length_for_type } from './types'\r\n\r\nimport { parseRFC3966 } from './RFC3966'\r\n\r\n// The minimum length of the national significant number.\r\nconst MIN_LENGTH_FOR_NSN = 2\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nconst MAX_LENGTH_FOR_NSN = 17\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// Pattern to capture digits used in an extension.\r\n// Places a maximum length of '7' for an extension.\r\nconst CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nconst EXTN_PATTERNS_FOR_PARSING =\r\n\tRFC3966_EXTN_PREFIX +\r\n\tCAPTURING_EXTN_DIGITS + '|' +\r\n\t'[ \\u00A0\\\\t,]*' +\r\n\t'(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' +\r\n\t'[;,x\\uFF58#\\uFF03~\\uFF5E]|int|anexo|\\uFF49\\uFF4E\\uFF54)' +\r\n\t'[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*' +\r\n\tCAPTURING_EXTN_DIGITS + '#?|' +\r\n\t'[- ]+([' + VALID_DIGITS + ']{1,5})#'\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nconst VALID_PHONE_NUMBER =\r\n\t\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t\t'(?:' +\r\n\t\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t\t'[' + VALID_DIGITS + ']' +\r\n\t\t'){3,}' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\r\n(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER +\r\n\t\t// Phone number extensions\r\n\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\r\n\t'$'\r\n,\r\n'i')\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\nconst default_options =\r\n{\r\n\tcountry: {}\r\n}\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\r\n\t{\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formatted_phone_number, ext } = parse_input(text)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formatted_phone_number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst\r\n\t{\r\n\t\tcountry,\r\n\t\tnational_number,\r\n\t\tcountryCallingCode\r\n\t}\r\n\t= parse_phone_number\r\n\t(\r\n\t\tformatted_phone_number,\r\n\t\toptions.defaultCountry,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.selectedCountry())\r\n\t{\r\n\t\treturn options.extended ? { countryCallingCode } : {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (national_number.length < MIN_LENGTH_FOR_NSN ||\r\n\t\tnational_number.length > MAX_LENGTH_FOR_NSN)\r\n\t{\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = country && matches_entirely(national_number, new RegExp(metadata.nationalNumberPattern())) ? true : false\r\n\r\n\tif (!options.extended)\r\n\t{\r\n\t\treturn valid ? result(country, national_number, ext) : {}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tvalid,\r\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(national_number, countryCallingCode !== undefined, metadata),\r\n\t\tphone    : national_number,\r\n\t\text\r\n\t}\r\n}\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport function is_viable_phone_number(number)\r\n{\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tmatches_entirely(number, VALID_PHONE_NUMBER_PATTERN)\r\n}\r\n\r\nexport function extract_formatted_phone_number(text)\r\n{\r\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided\r\nexport function strip_national_prefix(number, metadata)\r\n{\r\n\tif (!number || !metadata.nationalPrefixForParsing())\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but if the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn number\r\n\t}\r\n\r\n\tlet national_significant_number\r\n\r\n\t// `national_prefix_for_parsing` capturing groups\r\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\r\n\tconst any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1]\r\n\r\n\t// If the national number tranformation is needed then do it\r\n\tif (metadata.nationalPrefixTransformRule() && any_groups_were_captured)\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\r\n\t}\r\n\t// Else, no transformation is necessary,\r\n\t// and just strip the national prefix.\r\n\telse\r\n\t{\r\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\r\n\t}\r\n\r\n\t// // Verify the parsed national (significant) number for this country\r\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\r\n\t// //\r\n\t// // If the original number (before stripping national prefix) was viable,\r\n\t// // and the resultant number is not, then prefer the original phone number.\r\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// // a national prefix and a leading digit of a valid national phone number,\r\n\t// // like `8` is the national prefix for Russia and both\r\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t// if (matches_entirely(number, national_number_rule) &&\r\n\t// \t\t!matches_entirely(national_significant_number, national_number_rule))\r\n\t// {\r\n\t// \treturn number\r\n\t// }\r\n\r\n\t// Return the parsed national (significant) number\r\n   return national_significant_number\r\n}\r\n\r\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_calling_code` is always valid\r\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\tconst original_country = metadata.selectedCountry()\r\n\tconst country = _find_country_code(possible_countries, national_phone_number, metadata)\r\n\tmetadata.country(original_country)\r\n\treturn country\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\r\n{\r\n\tfor (const country of possible_countries)\r\n\t{\r\n\t\tmetadata.country(country)\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits())\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (get_number_type({ phone: national_phone_number, country }, metadata.metadata))\r\n\t\t{\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Sort out arguments\r\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `parse('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\ttext = arg_1\r\n\t}\r\n\telse throw new TypeError('A phone number for parsing must be a string.')\r\n\r\n\t// If \"default country\" argument is being passed\r\n\t// then move it to `options`.\r\n\t// `parse('88005553535', 'RU', [options], metadata)`.\r\n\tif (typeof arg_2 === 'string')\r\n\t{\r\n\t\tif (arg_4)\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\r\n\t\t\tmetadata = arg_4\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2 }\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t}\r\n\t// No \"resrict country\" argument is being passed.\r\n\t// International phone number is passed.\r\n\t// `parse('+78005553535', [options], metadata)`.\r\n\telse\r\n\t{\r\n\t\tif (arg_3)\r\n\t\t{\r\n\t\t\toptions  = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\r\n\t// Metadata is required.\r\n\tif (!metadata || !metadata.countries)\r\n\t{\r\n\t\tthrow new Error('Metadata is required')\r\n\t}\r\n\r\n\t// Apply default options.\r\n\tif (options)\r\n\t{\r\n\t\toptions = { ...default_options, ...options }\r\n\t}\r\n\telse\r\n\t{\r\n\t\toptions = default_options\r\n\t}\r\n\r\n\treturn { text, options, metadata: new Metadata(metadata) }\r\n}\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nfunction strip_extension(number)\r\n{\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst number_without_extension = number.slice(0, start)\r\n\t/* istanbul ignore if - seems a bit of a redundant check */\r\n\tif (!is_viable_phone_number(number_without_extension))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length)\r\n\t{\r\n\t\tif (matches[i] != null && matches[i].length > 0)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tnumber : number_without_extension,\r\n\t\t\t\text    : matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\nfunction is_possible_number(national_number, is_international, metadata)\r\n{\r\n\tswitch (check_number_length_for_type(national_number, undefined, metadata))\r\n\t{\r\n\t\tcase 'IS_POSSIBLE':\r\n\t\t\treturn true\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t// \treturn !is_international\r\n\t\tdefault:\r\n\t\t\treturn false\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses a viable international phone number.\r\n * Returns `{ country, national_number }`.\r\n */\r\nfunction get_country_and_national_number_international(country_calling_code, national_number, metadata)\r\n{\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst country = find_country_code(country_calling_code, national_number, metadata)\r\n\r\n\t// Formatting information for regions which share\r\n\t// a country calling code is contained by only one region\r\n\t// for performance reasons. For example, for NANPA region\r\n\t// (\"North American Numbering Plan Administration\",\r\n\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\r\n\t// it will be contained in the metadata for `US`.\r\n\tcountry ? metadata.country(country) : metadata.chooseCountryByCountryCallingCode(country_calling_code)\r\n\r\n\treturn { national_number, country }\r\n}\r\n\r\n/**\r\n * Parses a viable local phone number.\r\n * Returns `{ country, national_number }`.\r\n */\r\nfunction get_country_and_national_number_local(formatted_phone_number, default_country, metadata)\r\n{\r\n\tconst country = default_country\r\n\tmetadata.country(country)\r\n\r\n\tlet national_number = parse_phone_number_digits(formatted_phone_number)\r\n\r\n\t// Only strip national prefixes for non-international phone numbers\r\n\t// because national prefixes can't be present in international phone numbers.\r\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\r\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\r\n\t// and then it would assume that's a valid number which it isn't.\r\n\t// So no forgiveness for grandmas here.\r\n\t// The issue asking for this fix:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\r\n\tconst potential_national_number = strip_national_prefix(national_number, metadata)\r\n\r\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\r\n\tif (metadata.possibleLengths())\r\n\t{\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tswitch (check_number_length_for_type(potential_national_number, undefined, metadata))\r\n\t\t{\r\n\t\t\tcase 'TOO_SHORT':\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tnational_number = potential_national_number\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t// like `8` is the national prefix for Russia and both\r\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\tif (matches_entirely(national_number, metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matches_entirely(potential_national_number, metadata.nationalNumberPattern()))\r\n\t\t{\r\n\t\t\t// Keep the number without stripping national prefix.\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnational_number = potential_national_number\r\n\t\t}\r\n\t}\r\n\r\n\treturn { national_number, country }\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parse_input(text)\r\n{\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0)\r\n\t{\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\r\n\tlet number = extract_formatted_phone_number(text)\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!is_viable_phone_number(number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = strip_extension(number)\r\n\tif (with_extension_stripped.ext)\r\n\t{\r\n\t\treturn with_extension_stripped\r\n\t}\r\n\r\n\treturn { number }\r\n}\r\n\r\nfunction result(country, national_number, ext)\r\n{\r\n\tconst result =\r\n\t{\r\n\t\tcountry,\r\n\t\tphone : national_number\r\n\t}\r\n\r\n\tif (ext)\r\n\t{\r\n\t\tresult.ext = ext\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * Returns `{ country, countryCallingCode, national_number }`.\r\n */\r\nfunction parse_phone_number(formatted_phone_number, default_country, metadata)\r\n{\r\n\tconst { countryCallingCode, number } = parse_national_number_and_country_calling_code(formatted_phone_number, metadata)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tif (countryCallingCode)\r\n\t{\r\n\t\tconst result = get_country_and_national_number_international(countryCallingCode, number, metadata)\r\n\t\tresult.countryCallingCode = countryCallingCode\r\n\t\treturn result\r\n\t}\r\n\r\n\tif (default_country)\r\n\t{\r\n\t\tconst result = get_country_and_national_number_local(formatted_phone_number, default_country, metadata)\r\n\t\tmetadata.country(default_country)\r\n\t\tresult.countryCallingCode = metadata.countryCallingCode()\r\n\t\treturn result\r\n\t}\r\n\r\n\treturn {}\r\n}"]}